<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JS Reference VS Copy</title>
  </head>
  <body>
    <script>
      // start with strings, numbers and booleans

      // *** assigning variables that strings, numbers and bools to other variables is fine - this is copied and not referenced ***

      // Let's say we have an array
      let players = ['Wes', 'Sarah', 'Ryan', 'Poppy']
      // *** when assigning a variable that is an array or object to another variable, this is REFERENCED - so any changes to the array or object affect any and all references to it ***
      // Why? It's because that is an array reference, not an array copy. They both point to the same array!

      // and so to make a copy of it -
      let players2 = players.slice()
      console.log(players2)

      // or create a new array and concat the old one in
      let players3 = [].concat(players)

      // or use the new ES6 Spread
      let players4 = [...players]

      // or Array.from
      let players5 = Array.from(players)

      // The same thing goes for objects, let's say we have a person object

      // with Objects
      const person = {
        name: 'Wes Bos',
        age: 80
      }

      // and think we make a copy:

      // how do we take a copy instead?

      const person2 = Object.assign({}, person)

      // can also add any new properties or change properties with the third param in Object.assign

      const person3 = Object.assign({}, person, { age: 66 })

      // We will hopefully soon see the object ...spread

      // THINGS TO NOTE - THIS IS ONLY 1 LEVEL DEEP - BOTH FOR ARRAYS AND OBJECTS. So this will not update any nested array or objects.

      // cheap hack
      const person4 = JSON.parse(JSON.stringify(person))
    </script>
  </body>
</html>
